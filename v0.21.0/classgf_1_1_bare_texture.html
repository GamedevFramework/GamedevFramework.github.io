<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gamedev Framework (gf): gf::BareTexture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gf_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gamedev Framework (gf)<span id="projectnumber">&#160;0.21.0</span>
   </div>
   <div id="projectbrief">A C++17 framework for 2D games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegf.html">gf</a></li><li class="navelem"><a class="el" href="classgf_1_1_bare_texture.html">BareTexture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgf_1_1_bare_texture-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gf::BareTexture Class Reference<div class="ingroups"><a class="el" href="group__graphics.html">Graphics</a> &raquo; <a class="el" href="group__graphics__gpu.html">GPU Resources</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>An image that lives in the graphic memory that can be used for drawing.  
 <a href="classgf_1_1_bare_texture.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_texture_8h_source.html">gf/Texture.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for gf::BareTexture:</div>
<div class="dyncontent">
<div class="center"><img src="classgf_1_1_bare_texture__inherit__graph.png" border="0" usemap="#agf_1_1_bare_texture_inherit__map" alt="Inheritance graph"/></div>
<map name="agf_1_1_bare_texture_inherit__map" id="agf_1_1_bare_texture_inherit__map">
<area shape="rect" title="An image that lives in the graphic memory that can be used for drawing." alt="" coords="75,5,195,32"/>
<area shape="rect" href="classgf_1_1_alpha_texture.html" title="A texture with a single alpha channel." alt="" coords="5,80,132,107"/>
<area shape="rect" href="classgf_1_1_texture.html" title="A texture for colored images." alt="" coords="157,80,247,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aba5939a29c39c87a20b4ae74e95c59e3"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a> { <br />
&#160;&#160;<a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3acb5feb1b7314637725a2e73bdc9f7295">Color</a>
, <br />
&#160;&#160;<a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3a6132295fcf5570fb8b0a944ef322a598">Alpha</a>
<br />
 }</td></tr>
<tr class="memdesc:aba5939a29c39c87a20b4ae74e95c59e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format of the texture.  <a href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">More...</a><br /></td></tr>
<tr class="separator:aba5939a29c39c87a20b4ae74e95c59e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0338d095a74651505e53f6ef07df5f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#af0338d095a74651505e53f6ef07df5f0">BareTexture</a> (<a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a> format)</td></tr>
<tr class="memdesc:af0338d095a74651505e53f6ef07df5f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classgf_1_1_bare_texture.html#af0338d095a74651505e53f6ef07df5f0">More...</a><br /></td></tr>
<tr class="separator:af0338d095a74651505e53f6ef07df5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c9ebf03d5ffdffc2383f09f3ea900e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a67c9ebf03d5ffdffc2383f09f3ea900e">BareTexture</a> (<a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a> format, <a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a> size, const uint8_t *data)</td></tr>
<tr class="memdesc:a67c9ebf03d5ffdffc2383f09f3ea900e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the texture.  <a href="classgf_1_1_bare_texture.html#a67c9ebf03d5ffdffc2383f09f3ea900e">More...</a><br /></td></tr>
<tr class="separator:a67c9ebf03d5ffdffc2383f09f3ea900e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c719e0fcb28f65a3c3d52e60ab2de95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a5c719e0fcb28f65a3c3d52e60ab2de95">getFormat</a> () const</td></tr>
<tr class="memdesc:a5c719e0fcb28f65a3c3d52e60ab2de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the format of the texture.  <a href="classgf_1_1_bare_texture.html#a5c719e0fcb28f65a3c3d52e60ab2de95">More...</a><br /></td></tr>
<tr class="separator:a5c719e0fcb28f65a3c3d52e60ab2de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f98880e7ad13968b80c570a96f251bb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a3f98880e7ad13968b80c570a96f251bb">getName</a> () const</td></tr>
<tr class="memdesc:a3f98880e7ad13968b80c570a96f251bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal representation of the texture.  <a href="classgf_1_1_bare_texture.html#a3f98880e7ad13968b80c570a96f251bb">More...</a><br /></td></tr>
<tr class="separator:a3f98880e7ad13968b80c570a96f251bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27085d8e77fdf1a8e0db0b449b43ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#af27085d8e77fdf1a8e0db0b449b43ff6">getSize</a> () const</td></tr>
<tr class="memdesc:af27085d8e77fdf1a8e0db0b449b43ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the texture.  <a href="classgf_1_1_bare_texture.html#af27085d8e77fdf1a8e0db0b449b43ff6">More...</a><br /></td></tr>
<tr class="separator:af27085d8e77fdf1a8e0db0b449b43ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92130ad8a7d9f530c15418f9188c95ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a92130ad8a7d9f530c15418f9188c95ee">setSmooth</a> (bool smooth=true)</td></tr>
<tr class="memdesc:a92130ad8a7d9f530c15418f9188c95ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable the smooth filter.  <a href="classgf_1_1_bare_texture.html#a92130ad8a7d9f530c15418f9188c95ee">More...</a><br /></td></tr>
<tr class="separator:a92130ad8a7d9f530c15418f9188c95ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cb1cf572a84531a1e8e70d6a67777b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#ae3cb1cf572a84531a1e8e70d6a67777b">isSmooth</a> () const noexcept</td></tr>
<tr class="memdesc:ae3cb1cf572a84531a1e8e70d6a67777b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the smooth filter is enabled or not.  <a href="classgf_1_1_bare_texture.html#ae3cb1cf572a84531a1e8e70d6a67777b">More...</a><br /></td></tr>
<tr class="separator:ae3cb1cf572a84531a1e8e70d6a67777b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34860c67cf5bd39b7d04d290ecee427c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a34860c67cf5bd39b7d04d290ecee427c">setRepeated</a> (bool repeated=true)</td></tr>
<tr class="memdesc:a34860c67cf5bd39b7d04d290ecee427c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable repeating.  <a href="classgf_1_1_bare_texture.html#a34860c67cf5bd39b7d04d290ecee427c">More...</a><br /></td></tr>
<tr class="separator:a34860c67cf5bd39b7d04d290ecee427c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2ec79e47a8548775eca60fa9ab5ca6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#aeb2ec79e47a8548775eca60fa9ab5ca6">isRepeated</a> () const noexcept</td></tr>
<tr class="memdesc:aeb2ec79e47a8548775eca60fa9ab5ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the texture is repeated or not.  <a href="classgf_1_1_bare_texture.html#aeb2ec79e47a8548775eca60fa9ab5ca6">More...</a><br /></td></tr>
<tr class="separator:aeb2ec79e47a8548775eca60fa9ab5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa601abc5feec107d624fba1fe867d484"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#aa601abc5feec107d624fba1fe867d484">update</a> (const uint8_t *data)</td></tr>
<tr class="memdesc:aa601abc5feec107d624fba1fe867d484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the whole texture from an array of pixels.  <a href="classgf_1_1_bare_texture.html#aa601abc5feec107d624fba1fe867d484">More...</a><br /></td></tr>
<tr class="separator:aa601abc5feec107d624fba1fe867d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d196b5b4a8d2568f163c655cb0af34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#aa1d196b5b4a8d2568f163c655cb0af34">update</a> (const uint8_t *data, const <a class="el" href="group__core__geometry.html#ga2e3cde0dd67f7db84ca4e8ba9ce1fa64">RectI</a> &amp;rect)</td></tr>
<tr class="memdesc:aa1d196b5b4a8d2568f163c655cb0af34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a part of the texture from an array of pixels.  <a href="classgf_1_1_bare_texture.html#aa1d196b5b4a8d2568f163c655cb0af34">More...</a><br /></td></tr>
<tr class="separator:aa1d196b5b4a8d2568f163c655cb0af34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84def4bd8ba11c40b1a008f9b8f658f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#ad84def4bd8ba11c40b1a008f9b8f658f">resize</a> (<a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a> size, const uint8_t *data=nullptr)</td></tr>
<tr class="memdesc:ad84def4bd8ba11c40b1a008f9b8f658f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a texture.  <a href="classgf_1_1_bare_texture.html#ad84def4bd8ba11c40b1a008f9b8f658f">More...</a><br /></td></tr>
<tr class="separator:ad84def4bd8ba11c40b1a008f9b8f658f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed3f475c1cc89d564256b4d11670c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__core__geometry.html#gac3887a7df16895871374b04d9f6cb961">RectF</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a2aed3f475c1cc89d564256b4d11670c6">computeTextureCoords</a> (const <a class="el" href="group__core__geometry.html#ga2e3cde0dd67f7db84ca4e8ba9ce1fa64">RectI</a> &amp;rect) const</td></tr>
<tr class="memdesc:a2aed3f475c1cc89d564256b4d11670c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute normalized texture coordinates.  <a href="classgf_1_1_bare_texture.html#a2aed3f475c1cc89d564256b4d11670c6">More...</a><br /></td></tr>
<tr class="separator:a2aed3f475c1cc89d564256b4d11670c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303a01f6bd42fde0a6cae9787f66565c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#a303a01f6bd42fde0a6cae9787f66565c">generateMipmap</a> ()</td></tr>
<tr class="memdesc:a303a01f6bd42fde0a6cae9787f66565c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a mipmap using the current texture data.  <a href="classgf_1_1_bare_texture.html#a303a01f6bd42fde0a6cae9787f66565c">More...</a><br /></td></tr>
<tr class="separator:a303a01f6bd42fde0a6cae9787f66565c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae0a5581f2c93ff3029e14e3cbac72471"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgf_1_1_bare_texture.html#ae0a5581f2c93ff3029e14e3cbac72471">bind</a> (const <a class="el" href="classgf_1_1_bare_texture.html">BareTexture</a> *texture)</td></tr>
<tr class="memdesc:ae0a5581f2c93ff3029e14e3cbac72471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a texture for rendering.  <a href="classgf_1_1_bare_texture.html#ae0a5581f2c93ff3029e14e3cbac72471">More...</a><br /></td></tr>
<tr class="separator:ae0a5581f2c93ff3029e14e3cbac72471"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >An image that lives in the graphic memory that can be used for drawing. </p>
<p ><a class="el" href="classgf_1_1_bare_texture.html" title="An image that lives in the graphic memory that can be used for drawing.">gf::BareTexture</a> stores pixels that can be drawn, with a sprite for example. A texture lives in the graphics card memory, therefore it is very fast to draw a texture to a render target, or copy a render target to a texture (the graphics card can access both directly).</p>
<p >Being stored in the graphics card memory has some drawbacks. A texture cannot be manipulated as freely as a <a class="el" href="classgf_1_1_image.html" title="Class for loading, manipulating and saving images.">gf::Image</a>, you need to prepare the pixels first and then upload them to the texture in a single operation (see <a class="el" href="classgf_1_1_bare_texture.html#aa601abc5feec107d624fba1fe867d484" title="Update the whole texture from an array of pixels.">BareTexture::update()</a>).</p>
<p ><a class="el" href="classgf_1_1_bare_texture.html" title="An image that lives in the graphic memory that can be used for drawing.">gf::BareTexture</a> can handle two types of texture:</p>
<ul>
<li>colored texture that stores RGBA channels (see <a class="el" href="classgf_1_1_texture.html" title="A texture for colored images.">gf::Texture</a>)</li>
<li>alpha texture that stores a single alpha channel (see <a class="el" href="classgf_1_1_alpha_texture.html" title="A texture with a single alpha channel.">gf::AlphaTexture</a>)</li>
</ul>
<p >Generally, you do not manipulate a <a class="el" href="classgf_1_1_bare_texture.html" title="An image that lives in the graphic memory that can be used for drawing.">gf::BareTexture</a> directly but you can use a <a class="el" href="classgf_1_1_texture.html" title="A texture for colored images.">gf::Texture</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_texture.html" title="A texture for colored images.">gf::Texture</a>, <a class="el" href="classgf_1_1_alpha_texture.html" title="A texture with a single alpha channel.">gf::AlphaTexture</a> </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aba5939a29c39c87a20b4ae74e95c59e3" name="aba5939a29c39c87a20b4ae74e95c59e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5939a29c39c87a20b4ae74e95c59e3">&#9670;&nbsp;</a></span>Format</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">gf::BareTexture::Format</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Format of the texture. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_bare_texture.html" title="An image that lives in the graphic memory that can be used for drawing.">gf::BareTexture</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aba5939a29c39c87a20b4ae74e95c59e3acb5feb1b7314637725a2e73bdc9f7295" name="aba5939a29c39c87a20b4ae74e95c59e3acb5feb1b7314637725a2e73bdc9f7295"></a>Color&#160;</td><td class="fielddoc"><p >RGBA format. </p>
</td></tr>
<tr><td class="fieldname"><a id="aba5939a29c39c87a20b4ae74e95c59e3a6132295fcf5570fb8b0a944ef322a598" name="aba5939a29c39c87a20b4ae74e95c59e3a6132295fcf5570fb8b0a944ef322a598"></a>Alpha&#160;</td><td class="fielddoc"><p >Alpha format. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af0338d095a74651505e53f6ef07df5f0" name="af0338d095a74651505e53f6ef07df5f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0338d095a74651505e53f6ef07df5f0">&#9670;&nbsp;</a></span>BareTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gf::BareTexture::BareTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p >Once set, the format can not be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format of the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67c9ebf03d5ffdffc2383f09f3ea900e" name="a67c9ebf03d5ffdffc2383f09f3ea900e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c9ebf03d5ffdffc2383f09f3ea900e">&#9670;&nbsp;</a></span>BareTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gf::BareTexture::BareTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Format of the texture </td></tr>
    <tr><td class="paramname">size</td><td>Size of the texture </td></tr>
    <tr><td class="paramname">data</td><td>Initial pixels of the texture (can be <code>nullptr</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae0a5581f2c93ff3029e14e3cbac72471" name="ae0a5581f2c93ff3029e14e3cbac72471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a5581f2c93ff3029e14e3cbac72471">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gf::BareTexture::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgf_1_1_bare_texture.html">BareTexture</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a texture for rendering. </p>
<p >This function is for internal use only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>Pointer to the texture to bind, can be <code>nullptr</code> to use no texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2aed3f475c1cc89d564256b4d11670c6" name="a2aed3f475c1cc89d564256b4d11670c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed3f475c1cc89d564256b4d11670c6">&#9670;&nbsp;</a></span>computeTextureCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__geometry.html#gac3887a7df16895871374b04d9f6cb961">RectF</a> gf::BareTexture::computeTextureCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__core__geometry.html#ga2e3cde0dd67f7db84ca4e8ba9ce1fa64">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute normalized texture coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle in the texture, in pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Normalized texture coordinates </dd></dl>

</div>
</div>
<a id="a303a01f6bd42fde0a6cae9787f66565c" name="a303a01f6bd42fde0a6cae9787f66565c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303a01f6bd42fde0a6cae9787f66565c">&#9670;&nbsp;</a></span>generateMipmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gf::BareTexture::generateMipmap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a mipmap using the current texture data. </p>
<p >Mipmaps are pre-computed chains of optimized textures. Each level of texture in a mipmap is generated by halving each of the previous level's dimensions. This is done until the final level has the size of 1x1. The textures generated in this process may make use of more advanced filters which might improve the visual quality of textures when they are applied to objects much smaller than they are. This is known as minification. Because fewer texels (texture elements) have to be sampled from when heavily minified, usage of mipmaps can also improve rendering performance in certain scenarios.</p>
<p >Mipmap data is only valid from the time it is generated until the next time the base level image is modified, at which point this function will have to be called again to regenerate it.</p>
<dl class="section return"><dt>Returns</dt><dd>True if mipmap generation was successful, false if unsuccessful </dd></dl>

</div>
</div>
<a id="a5c719e0fcb28f65a3c3d52e60ab2de95" name="a5c719e0fcb28f65a3c3d52e60ab2de95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c719e0fcb28f65a3c3d52e60ab2de95">&#9670;&nbsp;</a></span>getFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgf_1_1_bare_texture.html#aba5939a29c39c87a20b4ae74e95c59e3">Format</a> gf::BareTexture::getFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the format of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>The format of the texture </dd></dl>

</div>
</div>
<a id="a3f98880e7ad13968b80c570a96f251bb" name="a3f98880e7ad13968b80c570a96f251bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f98880e7ad13968b80c570a96f251bb">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned gf::BareTexture::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the internal representation of the texture. </p>
<p >This function is for internal use only.</p>
<dl class="section return"><dt>Returns</dt><dd>The OpenGL name of the texture </dd></dl>

</div>
</div>
<a id="af27085d8e77fdf1a8e0db0b449b43ff6" name="af27085d8e77fdf1a8e0db0b449b43ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27085d8e77fdf1a8e0db0b449b43ff6">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a> gf::BareTexture::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the texture. </p>
<dl class="section return"><dt>Returns</dt><dd>Size in pixels </dd></dl>

</div>
</div>
<a id="aeb2ec79e47a8548775eca60fa9ab5ca6" name="aeb2ec79e47a8548775eca60fa9ab5ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2ec79e47a8548775eca60fa9ab5ca6">&#9670;&nbsp;</a></span>isRepeated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf::BareTexture::isRepeated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the texture is repeated or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if repeat mode is enabled, false if it is disabled</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_bare_texture.html#a34860c67cf5bd39b7d04d290ecee427c" title="Enable or disable repeating.">setRepeated()</a> </dd></dl>

</div>
</div>
<a id="ae3cb1cf572a84531a1e8e70d6a67777b" name="ae3cb1cf572a84531a1e8e70d6a67777b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cb1cf572a84531a1e8e70d6a67777b">&#9670;&nbsp;</a></span>isSmooth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gf::BareTexture::isSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the smooth filter is enabled or not. </p>
<dl class="section return"><dt>Returns</dt><dd>True if smoothing is enabled, false if it is disabled</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_bare_texture.html#a92130ad8a7d9f530c15418f9188c95ee" title="Enable or disable the smooth filter.">setSmooth()</a> </dd></dl>

</div>
</div>
<a id="ad84def4bd8ba11c40b1a008f9b8f658f" name="ad84def4bd8ba11c40b1a008f9b8f658f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84def4bd8ba11c40b1a008f9b8f658f">&#9670;&nbsp;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gf::BareTexture::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__core__maths.html#ga6db8376e8b54ea61befbc14817e6dde3">Vector2i</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the texture </td></tr>
    <tr><td class="paramname">data</td><td>An array of pixels (may be <code>nullptr</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34860c67cf5bd39b7d04d290ecee427c" name="a34860c67cf5bd39b7d04d290ecee427c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34860c67cf5bd39b7d04d290ecee427c">&#9670;&nbsp;</a></span>setRepeated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gf::BareTexture::setRepeated </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>repeated</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable repeating. </p>
<p >Repeating is involved when using texture coordinates outside the texture rectangle \( [0, 1] \times [0, 1] \). In this case, if repeat mode is enabled, the whole texture will be repeated as many times as needed to reach the coordinate (for example, if the \( u \) texture coordinate is 3, the texture will be repeated 3 times).</p>
<p >If repeat mode is disabled, the "extra space" will instead be filled with border pixels.</p>
<p >Repeating is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">repeated</td><td>True to repeat the texture, false to disable repeating</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_bare_texture.html#aeb2ec79e47a8548775eca60fa9ab5ca6" title="Check if the texture is repeated or not.">isRepeated()</a> </dd></dl>

</div>
</div>
<a id="a92130ad8a7d9f530c15418f9188c95ee" name="a92130ad8a7d9f530c15418f9188c95ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92130ad8a7d9f530c15418f9188c95ee">&#9670;&nbsp;</a></span>setSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gf::BareTexture::setSmooth </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smooth</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable the smooth filter. </p>
<p >When the filter is activated, the texture appears smoother so that pixels are less noticeable. However if you want the texture to look exactly the same as its source file, you should leave it disabled.</p>
<p >The smooth filter is disabled by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smooth</td><td>True to enable smoothing, false to disable it</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_bare_texture.html#ae3cb1cf572a84531a1e8e70d6a67777b" title="Check if the smooth filter is enabled or not.">isSmooth()</a> </dd></dl>

</div>
</div>
<a id="aa601abc5feec107d624fba1fe867d484" name="aa601abc5feec107d624fba1fe867d484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa601abc5feec107d624fba1fe867d484">&#9670;&nbsp;</a></span>update() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gf::BareTexture::update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the whole texture from an array of pixels. </p>
<p >The <code>data</code> array is assumed to be in the right format (4 channels for colored texture and 1 channel for alpha texture) and have the right size.</p>
<p >No additional check is performed on the size of the pixel array, passing invalid arguments will lead to an undefined behavior.</p>
<p >This function does nothing if <code>data</code> is <code>nullptr</code> or if the texture was not previously created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An array of pixels to copy to the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1d196b5b4a8d2568f163c655cb0af34" name="aa1d196b5b4a8d2568f163c655cb0af34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d196b5b4a8d2568f163c655cb0af34">&#9670;&nbsp;</a></span>update() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gf::BareTexture::update </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core__geometry.html#ga2e3cde0dd67f7db84ca4e8ba9ce1fa64">RectI</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update a part of the texture from an array of pixels. </p>
<p >The <code>data</code> array is assumed to be in the right format (4 channels for colored texture and 1 channel for alpha texture) and its size must match the size of the <code>rect</code> argument.</p>
<p >No additional check is performed on the size of the pixel array or the bounds of the area to update, passing invalid arguments will lead to an undefined behavior.</p>
<p >This function does nothing if <code>data</code> is <code>nullptr</code> or if the texture was not previously created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>An array of pixels to copy to the texture </td></tr>
    <tr><td class="paramname">rect</td><td>The region of the texture to update </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
