<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gamedev Framework (gf): gf::Vector&lt; T, N &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gf_logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gamedev Framework (gf)<span id="projectnumber">&#160;0.22.0</span>
   </div>
   <div id="projectbrief">A C++17 framework for 2D games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegf.html">gf</a></li><li class="navelem"><a class="el" href="structgf_1_1_vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structgf_1_1_vector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gf::Vector&lt; T, N &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__core.html">Core</a> &raquo; <a class="el" href="group__core__maths.html">Maths</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>General purpose math vector.  
 <a href="structgf_1_1_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_vector_8h_source.html">gf/Vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a067a3d3bd29d65b7519afdbdcc6fb5bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a067a3d3bd29d65b7519afdbdcc6fb5bc">Vector</a> ()=default</td></tr>
<tr class="memdesc:a067a3d3bd29d65b7519afdbdcc6fb5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="structgf_1_1_vector.html#a067a3d3bd29d65b7519afdbdcc6fb5bc">More...</a><br /></td></tr>
<tr class="separator:a067a3d3bd29d65b7519afdbdcc6fb5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54db448c85c7d94cd5852cda5273bb72"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a54db448c85c7d94cd5852cda5273bb72">Vector</a> (<a class="el" href="structgf_1_1_zero_type.html">ZeroType</a>) noexcept</td></tr>
<tr class="memdesc:a54db448c85c7d94cd5852cda5273bb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that zero the vector out.  <a href="structgf_1_1_vector.html#a54db448c85c7d94cd5852cda5273bb72">More...</a><br /></td></tr>
<tr class="separator:a54db448c85c7d94cd5852cda5273bb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c04892d0caa7e80e0ad8bf4952ff19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ae2c04892d0caa7e80e0ad8bf4952ff19">Vector</a> (T val) noexcept</td></tr>
<tr class="memdesc:ae2c04892d0caa7e80e0ad8bf4952ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that fills the vector with a value.  <a href="structgf_1_1_vector.html#ae2c04892d0caa7e80e0ad8bf4952ff19">More...</a><br /></td></tr>
<tr class="separator:ae2c04892d0caa7e80e0ad8bf4952ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1c22ce0941530f6ac78f74534119d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a01b1c22ce0941530f6ac78f74534119d">Vector</a> (const T *array)</td></tr>
<tr class="memdesc:a01b1c22ce0941530f6ac78f74534119d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes an array.  <a href="structgf_1_1_vector.html#a01b1c22ce0941530f6ac78f74534119d">More...</a><br /></td></tr>
<tr class="separator:a01b1c22ce0941530f6ac78f74534119d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc77c74b90e7a6d130483e04add590a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a8bc77c74b90e7a6d130483e04add590a">Vector</a> (std::initializer_list&lt; T &gt; list) noexcept</td></tr>
<tr class="memdesc:a8bc77c74b90e7a6d130483e04add590a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that takes an initializer list.  <a href="structgf_1_1_vector.html#a8bc77c74b90e7a6d130483e04add590a">More...</a><br /></td></tr>
<tr class="separator:a8bc77c74b90e7a6d130483e04add590a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4497f220f69f24804b8e2481c8c161b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#af4497f220f69f24804b8e2481c8c161b">Vector</a> (const <a class="el" href="structgf_1_1_vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:af4497f220f69f24804b8e2481c8c161b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy constructor.  <a href="structgf_1_1_vector.html#af4497f220f69f24804b8e2481c8c161b">More...</a><br /></td></tr>
<tr class="separator:af4497f220f69f24804b8e2481c8c161b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae995441370d5d32d4c0d1fe8d9108a38"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae995441370d5d32d4c0d1fe8d9108a38"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ae995441370d5d32d4c0d1fe8d9108a38">Vector</a> (const <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:ae995441370d5d32d4c0d1fe8d9108a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting copy constructor.  <a href="structgf_1_1_vector.html#ae995441370d5d32d4c0d1fe8d9108a38">More...</a><br /></td></tr>
<tr class="separator:ae995441370d5d32d4c0d1fe8d9108a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127d5bce5f31e226483471f5e6f52a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgf_1_1_vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a127d5bce5f31e226483471f5e6f52a6b">operator=</a> (const <a class="el" href="structgf_1_1_vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:a127d5bce5f31e226483471f5e6f52a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy assignment.  <a href="structgf_1_1_vector.html#a127d5bce5f31e226483471f5e6f52a6b">More...</a><br /></td></tr>
<tr class="separator:a127d5bce5f31e226483471f5e6f52a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e31709b45c087d0b00a188bf108697a"><td class="memItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1e31709b45c087d0b00a188bf108697a">operator[]</a> (std::size_t i) const</td></tr>
<tr class="memdesc:a1e31709b45c087d0b00a188bf108697a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the \( i \)-th coordinate.  <a href="structgf_1_1_vector.html#a1e31709b45c087d0b00a188bf108697a">More...</a><br /></td></tr>
<tr class="separator:a1e31709b45c087d0b00a188bf108697a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61042ce2445816f46f909702348ba85"><td class="memItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac61042ce2445816f46f909702348ba85">operator[]</a> (std::size_t i)</td></tr>
<tr class="memdesc:ac61042ce2445816f46f909702348ba85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the \( i \)-th coordinate.  <a href="structgf_1_1_vector.html#ac61042ce2445816f46f909702348ba85">More...</a><br /></td></tr>
<tr class="separator:ac61042ce2445816f46f909702348ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c880eb38121c3d9f5d06f5547b45634"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a2c880eb38121c3d9f5d06f5547b45634">begin</a> ()</td></tr>
<tr class="memdesc:a2c880eb38121c3d9f5d06f5547b45634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator.to the first element.  <a href="structgf_1_1_vector.html#a2c880eb38121c3d9f5d06f5547b45634">More...</a><br /></td></tr>
<tr class="separator:a2c880eb38121c3d9f5d06f5547b45634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4a818059ecad3d0edc2bbaea1a8eff"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#abd4a818059ecad3d0edc2bbaea1a8eff">end</a> ()</td></tr>
<tr class="memdesc:abd4a818059ecad3d0edc2bbaea1a8eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to the element after the last one.  <a href="structgf_1_1_vector.html#abd4a818059ecad3d0edc2bbaea1a8eff">More...</a><br /></td></tr>
<tr class="separator:abd4a818059ecad3d0edc2bbaea1a8eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d87cbe82da7811d9725740d1b47cdd5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1d87cbe82da7811d9725740d1b47cdd5">begin</a> () const</td></tr>
<tr class="memdesc:a1d87cbe82da7811d9725740d1b47cdd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator.to the first element (const version).  <a href="structgf_1_1_vector.html#a1d87cbe82da7811d9725740d1b47cdd5">More...</a><br /></td></tr>
<tr class="separator:a1d87cbe82da7811d9725740d1b47cdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d1c3f35f3b3e4beecd1a99074cb37"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a7b5d1c3f35f3b3e4beecd1a99074cb37">end</a> () const</td></tr>
<tr class="memdesc:a7b5d1c3f35f3b3e4beecd1a99074cb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on the element after the last one (const version).  <a href="structgf_1_1_vector.html#a7b5d1c3f35f3b3e4beecd1a99074cb37">More...</a><br /></td></tr>
<tr class="separator:a7b5d1c3f35f3b3e4beecd1a99074cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0dbbf29aa32b04efab1117f12a2dc5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aeb0dbbf29aa32b04efab1117f12a2dc5">cbegin</a> () const</td></tr>
<tr class="memdesc:aeb0dbbf29aa32b04efab1117f12a2dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator.on the first element (const version).  <a href="structgf_1_1_vector.html#aeb0dbbf29aa32b04efab1117f12a2dc5">More...</a><br /></td></tr>
<tr class="separator:aeb0dbbf29aa32b04efab1117f12a2dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6eeac3d72fe39ebd43aa2342ecbd1d"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aed6eeac3d72fe39ebd43aa2342ecbd1d">cend</a> () const</td></tr>
<tr class="memdesc:aed6eeac3d72fe39ebd43aa2342ecbd1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator on the element after the last one (const version).  <a href="structgf_1_1_vector.html#aed6eeac3d72fe39ebd43aa2342ecbd1d">More...</a><br /></td></tr>
<tr class="separator:aed6eeac3d72fe39ebd43aa2342ecbd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e89cccc4b20d492c7a0dbe0b5d384b"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a90e89cccc4b20d492c7a0dbe0b5d384b">zero</a> () noexcept</td></tr>
<tr class="memdesc:a90e89cccc4b20d492c7a0dbe0b5d384b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero out the vector.  <a href="structgf_1_1_vector.html#a90e89cccc4b20d492c7a0dbe0b5d384b">More...</a><br /></td></tr>
<tr class="separator:a90e89cccc4b20d492c7a0dbe0b5d384b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a247825a4b27adde52e67107d87987ca8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a247825a4b27adde52e67107d87987ca8">data</a> [N]</td></tr>
<tr class="memdesc:a247825a4b27adde52e67107d87987ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal representation of the vector.  <a href="structgf_1_1_vector.html#a247825a4b27adde52e67107d87987ca8">More...</a><br /></td></tr>
<tr class="separator:a247825a4b27adde52e67107d87987ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="related" name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p >(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a15f9e895116590549ded3adf7303fc80"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a15f9e895116590549ded3adf7303fc80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a15f9e895116590549ded3adf7303fc80">swap</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a15f9e895116590549ded3adf7303fc80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two vectors.  <a href="structgf_1_1_vector.html#a15f9e895116590549ded3adf7303fc80">More...</a><br /></td></tr>
<tr class="separator:a15f9e895116590549ded3adf7303fc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48195a02b7fe37c8c35e1ce89f4d6969"><td class="memTemplParams" colspan="2">template&lt;typename ... Types&gt; </td></tr>
<tr class="memitem:a48195a02b7fe37c8c35e1ce89f4d6969"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a> (Types... values) -&gt; <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; Types... &gt;, sizeof...(Types)&gt;</td></tr>
<tr class="memdesc:a48195a02b7fe37c8c35e1ce89f4d6969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal vector factory.  <a href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">More...</a><br /></td></tr>
<tr class="separator:a48195a02b7fe37c8c35e1ce89f4d6969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2623a6fdbc97d51457510e165fa8088b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2623a6fdbc97d51457510e165fa8088b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a2623a6fdbc97d51457510e165fa8088b">operator==</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a2623a6fdbc97d51457510e165fa8088b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator between two vectors.  <a href="structgf_1_1_vector.html#a2623a6fdbc97d51457510e165fa8088b">More...</a><br /></td></tr>
<tr class="separator:a2623a6fdbc97d51457510e165fa8088b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254133a19c30421247b4ea76380b5024"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a254133a19c30421247b4ea76380b5024"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a254133a19c30421247b4ea76380b5024">operator!=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a254133a19c30421247b4ea76380b5024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator between two vectors.  <a href="structgf_1_1_vector.html#a254133a19c30421247b4ea76380b5024">More...</a><br /></td></tr>
<tr class="separator:a254133a19c30421247b4ea76380b5024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc28e77627701136f80d1977cfff1da"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3bc28e77627701136f80d1977cfff1da"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a3bc28e77627701136f80d1977cfff1da">operator-</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; val)</td></tr>
<tr class="memdesc:a3bc28e77627701136f80d1977cfff1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise unary minus.  <a href="structgf_1_1_vector.html#a3bc28e77627701136f80d1977cfff1da">More...</a><br /></td></tr>
<tr class="separator:a3bc28e77627701136f80d1977cfff1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0839981cf3722b98600133bf7ab0b07e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a0839981cf3722b98600133bf7ab0b07e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a0839981cf3722b98600133bf7ab0b07e">operator+</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a0839981cf3722b98600133bf7ab0b07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise addition.  <a href="structgf_1_1_vector.html#a0839981cf3722b98600133bf7ab0b07e">More...</a><br /></td></tr>
<tr class="separator:a0839981cf3722b98600133bf7ab0b07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765312e5842339960abb7d536bfbe1b2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a765312e5842339960abb7d536bfbe1b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a765312e5842339960abb7d536bfbe1b2">operator+=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a765312e5842339960abb7d536bfbe1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise addition and assignment.  <a href="structgf_1_1_vector.html#a765312e5842339960abb7d536bfbe1b2">More...</a><br /></td></tr>
<tr class="separator:a765312e5842339960abb7d536bfbe1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef968d881f04036ccd6479be65f0866a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </td></tr>
<tr class="memitem:aef968d881f04036ccd6479be65f0866a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aef968d881f04036ccd6479be65f0866a">operator+</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, U rhs)</td></tr>
<tr class="memdesc:aef968d881f04036ccd6479be65f0866a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar addition.  <a href="structgf_1_1_vector.html#aef968d881f04036ccd6479be65f0866a">More...</a><br /></td></tr>
<tr class="separator:aef968d881f04036ccd6479be65f0866a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12778640823315695fecb02d5c79fb17"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a12778640823315695fecb02d5c79fb17"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a12778640823315695fecb02d5c79fb17">operator+=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:a12778640823315695fecb02d5c79fb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar addition and assignment.  <a href="structgf_1_1_vector.html#a12778640823315695fecb02d5c79fb17">More...</a><br /></td></tr>
<tr class="separator:a12778640823315695fecb02d5c79fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e76e287735d8ca7161a97c9ea3bbbf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:ae8e76e287735d8ca7161a97c9ea3bbbf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ae8e76e287735d8ca7161a97c9ea3bbbf">operator+</a> (T lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:ae8e76e287735d8ca7161a97c9ea3bbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left scalar addition.  <a href="structgf_1_1_vector.html#ae8e76e287735d8ca7161a97c9ea3bbbf">More...</a><br /></td></tr>
<tr class="separator:ae8e76e287735d8ca7161a97c9ea3bbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5216834ff74a5658248595cf54eaca02"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a5216834ff74a5658248595cf54eaca02"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a5216834ff74a5658248595cf54eaca02">operator-</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a5216834ff74a5658248595cf54eaca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise substraction.  <a href="structgf_1_1_vector.html#a5216834ff74a5658248595cf54eaca02">More...</a><br /></td></tr>
<tr class="separator:a5216834ff74a5658248595cf54eaca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b182de38d705ad74702e4ac27a43148"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a2b182de38d705ad74702e4ac27a43148"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a2b182de38d705ad74702e4ac27a43148">operator-=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a2b182de38d705ad74702e4ac27a43148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise substraction and assignment.  <a href="structgf_1_1_vector.html#a2b182de38d705ad74702e4ac27a43148">More...</a><br /></td></tr>
<tr class="separator:a2b182de38d705ad74702e4ac27a43148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac828d7a7cdbdda752c8ae435ea12df33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </td></tr>
<tr class="memitem:ac828d7a7cdbdda752c8ae435ea12df33"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac828d7a7cdbdda752c8ae435ea12df33">operator-</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, U rhs)</td></tr>
<tr class="memdesc:ac828d7a7cdbdda752c8ae435ea12df33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar substraction.  <a href="structgf_1_1_vector.html#ac828d7a7cdbdda752c8ae435ea12df33">More...</a><br /></td></tr>
<tr class="separator:ac828d7a7cdbdda752c8ae435ea12df33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106adae988b1e08b36c92f9ec6bef15"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a5106adae988b1e08b36c92f9ec6bef15"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a5106adae988b1e08b36c92f9ec6bef15">operator-=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:a5106adae988b1e08b36c92f9ec6bef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar substraction and assignment.  <a href="structgf_1_1_vector.html#a5106adae988b1e08b36c92f9ec6bef15">More...</a><br /></td></tr>
<tr class="separator:a5106adae988b1e08b36c92f9ec6bef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7de3c412b03b7efdb9230ca97d4118"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a6a7de3c412b03b7efdb9230ca97d4118"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a6a7de3c412b03b7efdb9230ca97d4118">operator-</a> (T lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a6a7de3c412b03b7efdb9230ca97d4118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left scalar substraction.  <a href="structgf_1_1_vector.html#a6a7de3c412b03b7efdb9230ca97d4118">More...</a><br /></td></tr>
<tr class="separator:a6a7de3c412b03b7efdb9230ca97d4118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f99ab5fa27fb2efd4a6398df8e260f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a3f99ab5fa27fb2efd4a6398df8e260f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a3f99ab5fa27fb2efd4a6398df8e260f6">operator*</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a3f99ab5fa27fb2efd4a6398df8e260f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise multiplication.  <a href="structgf_1_1_vector.html#a3f99ab5fa27fb2efd4a6398df8e260f6">More...</a><br /></td></tr>
<tr class="separator:a3f99ab5fa27fb2efd4a6398df8e260f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892f301f8dc21e642788115a738739c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a4892f301f8dc21e642788115a738739c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a4892f301f8dc21e642788115a738739c">operator*=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a4892f301f8dc21e642788115a738739c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise multiplication and assignment.  <a href="structgf_1_1_vector.html#a4892f301f8dc21e642788115a738739c">More...</a><br /></td></tr>
<tr class="separator:a4892f301f8dc21e642788115a738739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa37f51377425f1f3541e45922db98"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </td></tr>
<tr class="memitem:a1eaa37f51377425f1f3541e45922db98"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1eaa37f51377425f1f3541e45922db98">operator*</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, U rhs)</td></tr>
<tr class="memdesc:a1eaa37f51377425f1f3541e45922db98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar multiplication.  <a href="structgf_1_1_vector.html#a1eaa37f51377425f1f3541e45922db98">More...</a><br /></td></tr>
<tr class="separator:a1eaa37f51377425f1f3541e45922db98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705c85f28b50458abbb4544525722686"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:a705c85f28b50458abbb4544525722686"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a705c85f28b50458abbb4544525722686">operator*=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:a705c85f28b50458abbb4544525722686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar multiplication and assignment.  <a href="structgf_1_1_vector.html#a705c85f28b50458abbb4544525722686">More...</a><br /></td></tr>
<tr class="separator:a705c85f28b50458abbb4544525722686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb70d050088bf594043ed0ba06232ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a3eb70d050088bf594043ed0ba06232ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a3eb70d050088bf594043ed0ba06232ad">operator*</a> (T lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a3eb70d050088bf594043ed0ba06232ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left scalar multiplication.  <a href="structgf_1_1_vector.html#a3eb70d050088bf594043ed0ba06232ad">More...</a><br /></td></tr>
<tr class="separator:a3eb70d050088bf594043ed0ba06232ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab881f7d5127c35d12326813626b3ede0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:ab881f7d5127c35d12326813626b3ede0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ab881f7d5127c35d12326813626b3ede0">operator/</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:ab881f7d5127c35d12326813626b3ede0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise division.  <a href="structgf_1_1_vector.html#ab881f7d5127c35d12326813626b3ede0">More...</a><br /></td></tr>
<tr class="separator:ab881f7d5127c35d12326813626b3ede0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0fe611e4f39fda1147dcb21f9a3df9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:ada0fe611e4f39fda1147dcb21f9a3df9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ada0fe611e4f39fda1147dcb21f9a3df9">operator/=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:ada0fe611e4f39fda1147dcb21f9a3df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise division and assignment.  <a href="structgf_1_1_vector.html#ada0fe611e4f39fda1147dcb21f9a3df9">More...</a><br /></td></tr>
<tr class="separator:ada0fe611e4f39fda1147dcb21f9a3df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bb370ac82deba952f69392149c2915"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </td></tr>
<tr class="memitem:a39bb370ac82deba952f69392149c2915"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a39bb370ac82deba952f69392149c2915">operator/</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, U rhs)</td></tr>
<tr class="memdesc:a39bb370ac82deba952f69392149c2915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar division.  <a href="structgf_1_1_vector.html#a39bb370ac82deba952f69392149c2915">More...</a><br /></td></tr>
<tr class="separator:a39bb370ac82deba952f69392149c2915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb635d386ec828efac5c2acbca5e7362"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:abb635d386ec828efac5c2acbca5e7362"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#abb635d386ec828efac5c2acbca5e7362">operator/=</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;lhs, U rhs)</td></tr>
<tr class="memdesc:abb635d386ec828efac5c2acbca5e7362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Right scalar division and assignment.  <a href="structgf_1_1_vector.html#abb635d386ec828efac5c2acbca5e7362">More...</a><br /></td></tr>
<tr class="separator:abb635d386ec828efac5c2acbca5e7362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4303bee223d720052cdeb47ef5737255"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </td></tr>
<tr class="memitem:a4303bee223d720052cdeb47ef5737255"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a4303bee223d720052cdeb47ef5737255">operator/</a> (T lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; rhs)</td></tr>
<tr class="memdesc:a4303bee223d720052cdeb47ef5737255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Left scalar division.  <a href="structgf_1_1_vector.html#a4303bee223d720052cdeb47ef5737255">More...</a><br /></td></tr>
<tr class="separator:a4303bee223d720052cdeb47ef5737255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf0c3d205c768d088a006a1fd7097f0"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a8cf0c3d205c768d088a006a1fd7097f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a8cf0c3d205c768d088a006a1fd7097f0">operator||</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; rhs)</td></tr>
<tr class="memdesc:a8cf0c3d205c768d088a006a1fd7097f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise logical or operator.  <a href="structgf_1_1_vector.html#a8cf0c3d205c768d088a006a1fd7097f0">More...</a><br /></td></tr>
<tr class="separator:a8cf0c3d205c768d088a006a1fd7097f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55421f25f24c00853208f886647d1b3"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac55421f25f24c00853208f886647d1b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac55421f25f24c00853208f886647d1b3">operator&amp;&amp;</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; rhs)</td></tr>
<tr class="memdesc:ac55421f25f24c00853208f886647d1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise logical and operator.  <a href="structgf_1_1_vector.html#ac55421f25f24c00853208f886647d1b3">More...</a><br /></td></tr>
<tr class="separator:ac55421f25f24c00853208f886647d1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d59e5753b5619ff30f9f10659e5262"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a68d59e5753b5619ff30f9f10659e5262"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a68d59e5753b5619ff30f9f10659e5262">dot</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a68d59e5753b5619ff30f9f10659e5262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scalar product.  <a href="structgf_1_1_vector.html#a68d59e5753b5619ff30f9f10659e5262">More...</a><br /></td></tr>
<tr class="separator:a68d59e5753b5619ff30f9f10659e5262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a442989e5524f0cb5eade69385467f6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3a442989e5524f0cb5eade69385467f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a3a442989e5524f0cb5eade69385467f6">min</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a3a442989e5524f0cb5eade69385467f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise minimum.  <a href="structgf_1_1_vector.html#a3a442989e5524f0cb5eade69385467f6">More...</a><br /></td></tr>
<tr class="separator:a3a442989e5524f0cb5eade69385467f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c86499fb47f364a434a53218d769afb"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0c86499fb47f364a434a53218d769afb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a0c86499fb47f364a434a53218d769afb">max</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a0c86499fb47f364a434a53218d769afb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise maximum.  <a href="structgf_1_1_vector.html#a0c86499fb47f364a434a53218d769afb">More...</a><br /></td></tr>
<tr class="separator:a0c86499fb47f364a434a53218d769afb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a904f7008f374c70a3da29cdbfa35a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a68a904f7008f374c70a3da29cdbfa35a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a68a904f7008f374c70a3da29cdbfa35a">abs</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; val)</td></tr>
<tr class="memdesc:a68a904f7008f374c70a3da29cdbfa35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise absolute value.  <a href="structgf_1_1_vector.html#a68a904f7008f374c70a3da29cdbfa35a">More...</a><br /></td></tr>
<tr class="separator:a68a904f7008f374c70a3da29cdbfa35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c56c0264d3d4f355ac8ac1f7849491"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab2c56c0264d3d4f355ac8ac1f7849491"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; int, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ab2c56c0264d3d4f355ac8ac1f7849491">sign</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; val)</td></tr>
<tr class="memdesc:ab2c56c0264d3d4f355ac8ac1f7849491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise sign value.  <a href="structgf_1_1_vector.html#ab2c56c0264d3d4f355ac8ac1f7849491">More...</a><br /></td></tr>
<tr class="separator:ab2c56c0264d3d4f355ac8ac1f7849491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603e565c3169edbd39c9c8cb2171b836"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a603e565c3169edbd39c9c8cb2171b836"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a603e565c3169edbd39c9c8cb2171b836">equals</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a603e565c3169edbd39c9c8cb2171b836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise equality operator.  <a href="structgf_1_1_vector.html#a603e565c3169edbd39c9c8cb2171b836">More...</a><br /></td></tr>
<tr class="separator:a603e565c3169edbd39c9c8cb2171b836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d10bb9a17347e5c51c10ad81319f0ba"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8d10bb9a17347e5c51c10ad81319f0ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a8d10bb9a17347e5c51c10ad81319f0ba">lessThan</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a8d10bb9a17347e5c51c10ad81319f0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise comparison operator.  <a href="structgf_1_1_vector.html#a8d10bb9a17347e5c51c10ad81319f0ba">More...</a><br /></td></tr>
<tr class="separator:a8d10bb9a17347e5c51c10ad81319f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ddc8921435df311fc45b2a34e82a4f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ac8ddc8921435df311fc45b2a34e82a4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac8ddc8921435df311fc45b2a34e82a4f">greaterThan</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:ac8ddc8921435df311fc45b2a34e82a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise comparison operator.  <a href="structgf_1_1_vector.html#ac8ddc8921435df311fc45b2a34e82a4f">More...</a><br /></td></tr>
<tr class="separator:ac8ddc8921435df311fc45b2a34e82a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffb16899f596dfde6ed7945ca363697"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1ffb16899f596dfde6ed7945ca363697"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1ffb16899f596dfde6ed7945ca363697">select</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; cond, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a1ffb16899f596dfde6ed7945ca363697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise selection operator.  <a href="structgf_1_1_vector.html#a1ffb16899f596dfde6ed7945ca363697">More...</a><br /></td></tr>
<tr class="separator:a1ffb16899f596dfde6ed7945ca363697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda04c94501a220cde97774e2bd6803"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aafda04c94501a220cde97774e2bd6803"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aafda04c94501a220cde97774e2bd6803">clamp</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; val, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lo, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; hi)</td></tr>
<tr class="memdesc:aafda04c94501a220cde97774e2bd6803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise clamp function.  <a href="structgf_1_1_vector.html#aafda04c94501a220cde97774e2bd6803">More...</a><br /></td></tr>
<tr class="separator:aafda04c94501a220cde97774e2bd6803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7af705704cd45f3120a8d0fb8233ac"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3e7af705704cd45f3120a8d0fb8233ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a3e7af705704cd45f3120a8d0fb8233ac">clamp</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; val, T lo, T hi)</td></tr>
<tr class="memdesc:a3e7af705704cd45f3120a8d0fb8233ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise clamp function.  <a href="structgf_1_1_vector.html#a3e7af705704cd45f3120a8d0fb8233ac">More...</a><br /></td></tr>
<tr class="separator:a3e7af705704cd45f3120a8d0fb8233ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd4d75836a670db74ead8aa141bf088"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , std::size_t N&gt; </td></tr>
<tr class="memitem:aabd4d75836a670db74ead8aa141bf088"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aabd4d75836a670db74ead8aa141bf088">lerp</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs, U t)</td></tr>
<tr class="memdesc:aabd4d75836a670db74ead8aa141bf088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component-wise lerp function.  <a href="structgf_1_1_vector.html#aabd4d75836a670db74ead8aa141bf088">More...</a><br /></td></tr>
<tr class="separator:aabd4d75836a670db74ead8aa141bf088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e84f24664d006f2fff11c89059ef52"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a13e84f24664d006f2fff11c89059ef52"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a13e84f24664d006f2fff11c89059ef52">manhattanLength</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a13e84f24664d006f2fff11c89059ef52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manhattan length of a vector.  <a href="structgf_1_1_vector.html#a13e84f24664d006f2fff11c89059ef52">More...</a><br /></td></tr>
<tr class="separator:a13e84f24664d006f2fff11c89059ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1955a31725e521021b0be0ab2871be50"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1955a31725e521021b0be0ab2871be50"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1955a31725e521021b0be0ab2871be50">squareLength</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a1955a31725e521021b0be0ab2871be50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square Euclidean length of a vector.  <a href="structgf_1_1_vector.html#a1955a31725e521021b0be0ab2871be50">More...</a><br /></td></tr>
<tr class="separator:a1955a31725e521021b0be0ab2871be50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b81f7458166ea6cf9a7365b947cf6a0"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5b81f7458166ea6cf9a7365b947cf6a0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a5b81f7458166ea6cf9a7365b947cf6a0">euclideanLength</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a5b81f7458166ea6cf9a7365b947cf6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean length of a vector.  <a href="structgf_1_1_vector.html#a5b81f7458166ea6cf9a7365b947cf6a0">More...</a><br /></td></tr>
<tr class="separator:a5b81f7458166ea6cf9a7365b947cf6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea65ac04f9577ddf229f2b67250db6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aafea65ac04f9577ddf229f2b67250db6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aafea65ac04f9577ddf229f2b67250db6">chebyshevLength</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:aafea65ac04f9577ddf229f2b67250db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev length of a vector.  <a href="structgf_1_1_vector.html#aafea65ac04f9577ddf229f2b67250db6">More...</a><br /></td></tr>
<tr class="separator:aafea65ac04f9577ddf229f2b67250db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5d34e6962eb33c8d23a67c2a67a691"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9e5d34e6962eb33c8d23a67c2a67a691"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a9e5d34e6962eb33c8d23a67c2a67a691">naturalLength</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a9e5d34e6962eb33c8d23a67c2a67a691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural length of a vector.  <a href="structgf_1_1_vector.html#a9e5d34e6962eb33c8d23a67c2a67a691">More...</a><br /></td></tr>
<tr class="separator:a9e5d34e6962eb33c8d23a67c2a67a691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ac075b031168cc0333c60bf5f9ed91"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab7ac075b031168cc0333c60bf5f9ed91"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ab7ac075b031168cc0333c60bf5f9ed91">manhattanDistance</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:ab7ac075b031168cc0333c60bf5f9ed91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manhattan distance between two vectors.  <a href="structgf_1_1_vector.html#ab7ac075b031168cc0333c60bf5f9ed91">More...</a><br /></td></tr>
<tr class="separator:ab7ac075b031168cc0333c60bf5f9ed91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2b906d7231d200eb766187b5f51936"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6c2b906d7231d200eb766187b5f51936"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a6c2b906d7231d200eb766187b5f51936">squareDistance</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a6c2b906d7231d200eb766187b5f51936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square Euclidean distance between two vectors.  <a href="structgf_1_1_vector.html#a6c2b906d7231d200eb766187b5f51936">More...</a><br /></td></tr>
<tr class="separator:a6c2b906d7231d200eb766187b5f51936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbcb2190ca4bd2fb435f1e74f00c7db"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1bbcb2190ca4bd2fb435f1e74f00c7db"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1bbcb2190ca4bd2fb435f1e74f00c7db">euclideanDistance</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a1bbcb2190ca4bd2fb435f1e74f00c7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean distance between two vectors.  <a href="structgf_1_1_vector.html#a1bbcb2190ca4bd2fb435f1e74f00c7db">More...</a><br /></td></tr>
<tr class="separator:a1bbcb2190ca4bd2fb435f1e74f00c7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7e8d54b4bfa8292c7927c5fc9f2386"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a8b7e8d54b4bfa8292c7927c5fc9f2386"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a8b7e8d54b4bfa8292c7927c5fc9f2386">chebyshevDistance</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:a8b7e8d54b4bfa8292c7927c5fc9f2386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chebyshev distance between two vectors.  <a href="structgf_1_1_vector.html#a8b7e8d54b4bfa8292c7927c5fc9f2386">More...</a><br /></td></tr>
<tr class="separator:a8b7e8d54b4bfa8292c7927c5fc9f2386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa156019ca0df0875f1905e24dc008d05"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aa156019ca0df0875f1905e24dc008d05"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#aa156019ca0df0875f1905e24dc008d05">naturalDistance</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; rhs)</td></tr>
<tr class="memdesc:aa156019ca0df0875f1905e24dc008d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Natural distance between two vectors.  <a href="structgf_1_1_vector.html#aa156019ca0df0875f1905e24dc008d05">More...</a><br /></td></tr>
<tr class="separator:aa156019ca0df0875f1905e24dc008d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff13e50288e1deeb196aa12df06d883"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4ff13e50288e1deeb196aa12df06d883"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a4ff13e50288e1deeb196aa12df06d883">normalize</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a4ff13e50288e1deeb196aa12df06d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a vector.  <a href="structgf_1_1_vector.html#a4ff13e50288e1deeb196aa12df06d883">More...</a><br /></td></tr>
<tr class="separator:a4ff13e50288e1deeb196aa12df06d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b79951b622a9fa2b28d172e3012db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a056b79951b622a9fa2b28d172e3012db"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a056b79951b622a9fa2b28d172e3012db">projx</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a056b79951b622a9fa2b28d172e3012db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector on the x axis.  <a href="structgf_1_1_vector.html#a056b79951b622a9fa2b28d172e3012db">More...</a><br /></td></tr>
<tr class="separator:a056b79951b622a9fa2b28d172e3012db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f4ccecff2cf95ae1313eb9bcc99d66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51f4ccecff2cf95ae1313eb9bcc99d66"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a51f4ccecff2cf95ae1313eb9bcc99d66">projy</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a51f4ccecff2cf95ae1313eb9bcc99d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project the vector on the y axis.  <a href="structgf_1_1_vector.html#a51f4ccecff2cf95ae1313eb9bcc99d66">More...</a><br /></td></tr>
<tr class="separator:a51f4ccecff2cf95ae1313eb9bcc99d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fc841041b29612070bd3243e269d32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6fc841041b29612070bd3243e269d32"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac6fc841041b29612070bd3243e269d32">dirx</a> (T length)</td></tr>
<tr class="memdesc:ac6fc841041b29612070bd3243e269d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector in the x direction.  <a href="structgf_1_1_vector.html#ac6fc841041b29612070bd3243e269d32">More...</a><br /></td></tr>
<tr class="separator:ac6fc841041b29612070bd3243e269d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634b932d718e72231b66831952a9175a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a634b932d718e72231b66831952a9175a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a634b932d718e72231b66831952a9175a">diry</a> (T length)</td></tr>
<tr class="memdesc:a634b932d718e72231b66831952a9175a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a vector in the y direction.  <a href="structgf_1_1_vector.html#a634b932d718e72231b66831952a9175a">More...</a><br /></td></tr>
<tr class="separator:a634b932d718e72231b66831952a9175a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba83d14d9bc5292fcf5ab39f596440b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ba83d14d9bc5292fcf5ab39f596440b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1ba83d14d9bc5292fcf5ab39f596440b">unit</a> (T <a class="el" href="structgf_1_1_vector.html#a18e6f216b07d4883920dc5677a4fe92c">angle</a>)</td></tr>
<tr class="memdesc:a1ba83d14d9bc5292fcf5ab39f596440b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit vector in a specified direction.  <a href="structgf_1_1_vector.html#a1ba83d14d9bc5292fcf5ab39f596440b">More...</a><br /></td></tr>
<tr class="separator:a1ba83d14d9bc5292fcf5ab39f596440b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e6f216b07d4883920dc5677a4fe92c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18e6f216b07d4883920dc5677a4fe92c"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a18e6f216b07d4883920dc5677a4fe92c">angle</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a18e6f216b07d4883920dc5677a4fe92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angle of a vector relative to the x-axis.  <a href="structgf_1_1_vector.html#a18e6f216b07d4883920dc5677a4fe92c">More...</a><br /></td></tr>
<tr class="separator:a18e6f216b07d4883920dc5677a4fe92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aceef07438afe7fb1157efe584591cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aceef07438afe7fb1157efe584591cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a1aceef07438afe7fb1157efe584591cc">perp</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; <a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a1aceef07438afe7fb1157efe584591cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perpendicular vector.  <a href="structgf_1_1_vector.html#a1aceef07438afe7fb1157efe584591cc">More...</a><br /></td></tr>
<tr class="separator:a1aceef07438afe7fb1157efe584591cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94acbf0840ef48fe234997a3bd948083"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94acbf0840ef48fe234997a3bd948083"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a94acbf0840ef48fe234997a3bd948083">vectorTripleProduct</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; a, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; b, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; c)</td></tr>
<tr class="memdesc:a94acbf0840ef48fe234997a3bd948083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Regular vector triple product.  <a href="structgf_1_1_vector.html#a94acbf0840ef48fe234997a3bd948083">More...</a><br /></td></tr>
<tr class="separator:a94acbf0840ef48fe234997a3bd948083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca9070f7b752a57d736a5643244eae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adeca9070f7b752a57d736a5643244eae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#adeca9070f7b752a57d736a5643244eae">inverseVectorTripleProduct</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; a, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; b, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; c)</td></tr>
<tr class="memdesc:adeca9070f7b752a57d736a5643244eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse vector triple product.  <a href="structgf_1_1_vector.html#adeca9070f7b752a57d736a5643244eae">More...</a><br /></td></tr>
<tr class="separator:adeca9070f7b752a57d736a5643244eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c7b0f2832ebb10c93344ada3e196c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9c7b0f2832ebb10c93344ada3e196c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ac9c7b0f2832ebb10c93344ada3e196c2">cross</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; rhs)</td></tr>
<tr class="memdesc:ac9c7b0f2832ebb10c93344ada3e196c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product for 2D vectors.  <a href="structgf_1_1_vector.html#ac9c7b0f2832ebb10c93344ada3e196c2">More...</a><br /></td></tr>
<tr class="separator:ac9c7b0f2832ebb10c93344ada3e196c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7dc23b70392429718b79fe1d8b5e36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace7dc23b70392429718b79fe1d8b5e36"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#ace7dc23b70392429718b79fe1d8b5e36">cross</a> (<a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt; lhs, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt; rhs)</td></tr>
<tr class="memdesc:ace7dc23b70392429718b79fe1d8b5e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cross product for 3D vectors.  <a href="structgf_1_1_vector.html#ace7dc23b70392429718b79fe1d8b5e36">More...</a><br /></td></tr>
<tr class="separator:ace7dc23b70392429718b79fe1d8b5e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0809b1e380f831557e4c6eef6111b30f"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0809b1e380f831557e4c6eef6111b30f"><td class="memTemplItemLeft" align="right" valign="top">Archive &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgf_1_1_vector.html#a0809b1e380f831557e4c6eef6111b30f">operator|</a> (Archive &amp;ar, <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;<a class="el" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>)</td></tr>
<tr class="memdesc:a0809b1e380f831557e4c6eef6111b30f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize and deserialize a vector.  <a href="structgf_1_1_vector.html#a0809b1e380f831557e4c6eef6111b30f">More...</a><br /></td></tr>
<tr class="separator:a0809b1e380f831557e4c6eef6111b30f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, std::size_t N&gt;<br />
struct gf::Vector&lt; T, N &gt;</div><p >General purpose math vector. </p>
<p ><a class="el" href="structgf_1_1_vector.html" title="General purpose math vector.">gf::Vector</a> is a class that represents an element of a <code>N</code>-dimensional space. It is used throughout the library for different purposes.</p>
<p >The template parameter <code>T</code> is the type of coordinates. . It can be any type that supports arithmetic operations (+, -, *, /) and relational operators (==, !=, &lt;, &gt;).</p>
<p >Several specializations are defined for common use cases:</p>
<ul>
<li>For dimension 2: <a class="el" href="structgf_1_1_vector_3_01_t_00_012_01_4.html" title="A 2D vector.">gf::Vector&lt;T, 2&gt;</a></li>
<li>For dimension 3: <a class="el" href="structgf_1_1_vector_3_01_t_00_013_01_4.html" title="A 3D vector.">gf::Vector&lt;T, 3&gt;</a></li>
<li>For dimension 4: <a class="el" href="structgf_1_1_vector_3_01_t_00_014_01_4.html" title="A 4D vector.">gf::Vector&lt;T, 4&gt;</a></li>
</ul>
<p >This class was designed according to the article <a href="http://www.reedbeta.com/blog/2013/12/28/on-vector-math-libraries/">On Vector Math Libraries</a> by Nathan Reed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a067a3d3bd29d65b7519afdbdcc6fb5bc" name="a067a3d3bd29d65b7519afdbdcc6fb5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067a3d3bd29d65b7519afdbdcc6fb5bc">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p >This constructor is defaulted so that this type is <a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">trivial</a>. </p>

</div>
</div>
<a id="a54db448c85c7d94cd5852cda5273bb72" name="a54db448c85c7d94cd5852cda5273bb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54db448c85c7d94cd5852cda5273bb72">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_zero_type.html">ZeroType</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that zero the vector out. </p>

</div>
</div>
<a id="ae2c04892d0caa7e80e0ad8bf4952ff19" name="ae2c04892d0caa7e80e0ad8bf4952ff19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c04892d0caa7e80e0ad8bf4952ff19">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that fills the vector with a value. </p>
<p >This constructor takes a value and fills the entire vector with this value. Care must be taken when calling this constructor:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;int, 5&gt;</a> vecOK(42); <span class="comment">// OK, vector is filled with 42</span></div>
<div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;int, 5&gt;</a> vecKO{42}; <span class="comment">// KO, vector is initialized with a 42 in the first coordinate</span></div>
<div class="ttc" id="astructgf_1_1_vector_html"><div class="ttname"><a href="structgf_1_1_vector.html">gf::Vector</a></div><div class="ttdoc">General purpose math vector.</div><div class="ttdef"><b>Definition:</b> Vector.h:61</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to fill the vector with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01b1c22ce0941530f6ac78f74534119d" name="a01b1c22ce0941530f6ac78f74534119d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1c22ce0941530f6ac78f74534119d">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes an array. </p>
<p >This constructor can ease conversion from other math libraries. The array must contain enough data for <code>N</code> dimensions.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> array[5] = { 1.0f, -1.0f, 0.5f, -2.0f, 0.0f };</div>
<div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;float, 5&gt;</a> <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>(array);</div>
<div class="ttc" id="astructgf_1_1_vector_html_a48195a02b7fe37c8c35e1ce89f4d6969"><div class="ttname"><a href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">gf::Vector::vec</a></div><div class="ttdeci">constexpr auto vec(Types... values) -&gt; Vector&lt; std::common_type_t&lt; Types... &gt;, sizeof...(Types)&gt;</div><div class="ttdoc">Universal vector factory.</div><div class="ttdef"><b>Definition:</b> Vector.h:1407</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array with the values of the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc77c74b90e7a6d130483e04add590a" name="a8bc77c74b90e7a6d130483e04add590a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc77c74b90e7a6d130483e04add590a">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that takes an initializer list. </p>
<p >This constructor allows to use an initializer list to define the coordinates of the vector.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;bool, 5&gt;</a> vec1{ <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span> };</div>
<div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;bool, 5&gt;</a> vec2 = { <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span> };</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>An initializer list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4497f220f69f24804b8e2481c8c161b" name="af4497f220f69f24804b8e2481c8c161b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4497f220f69f24804b8e2481c8c161b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy constructor. </p>
<p >This constructor is defaulted so that this type is <a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">trivial</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae995441370d5d32d4c0d1fe8d9108a38" name="ae995441370d5d32d4c0d1fe8d9108a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae995441370d5d32d4c0d1fe8d9108a38">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2c880eb38121c3d9f5d06f5547b45634" name="a2c880eb38121c3d9f5d06f5547b45634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c880eb38121c3d9f5d06f5547b45634">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator.to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first element. </dd></dl>

</div>
</div>
<a id="a1d87cbe82da7811d9725740d1b47cdd5" name="a1d87cbe82da7811d9725740d1b47cdd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d87cbe82da7811d9725740d1b47cdd5">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator.to the first element (const version). </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer on the first const element. </dd></dl>

</div>
</div>
<a id="aeb0dbbf29aa32b04efab1117f12a2dc5" name="aeb0dbbf29aa32b04efab1117f12a2dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0dbbf29aa32b04efab1117f12a2dc5">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator.on the first element (const version). </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer on the first const element. </dd></dl>

</div>
</div>
<a id="aed6eeac3d72fe39ebd43aa2342ecbd1d" name="aed6eeac3d72fe39ebd43aa2342ecbd1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6eeac3d72fe39ebd43aa2342ecbd1d">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator on the element after the last one (const version). </p>
<dl class="section return"><dt>Returns</dt><dd>An invalid pointer that is the adress after the last const element. </dd></dl>

</div>
</div>
<a id="abd4a818059ecad3d0edc2bbaea1a8eff" name="abd4a818059ecad3d0edc2bbaea1a8eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4a818059ecad3d0edc2bbaea1a8eff">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator to the element after the last one. </p>
<dl class="section return"><dt>Returns</dt><dd>An invalid pointer that is the adress after the last element. </dd></dl>

</div>
</div>
<a id="a7b5d1c3f35f3b3e4beecd1a99074cb37" name="a7b5d1c3f35f3b3e4beecd1a99074cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d1c3f35f3b3e4beecd1a99074cb37">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterator on the element after the last one (const version). </p>
<dl class="section return"><dt>Returns</dt><dd>An invalid pointer that is the adress after the last const element. </dd></dl>

</div>
</div>
<a id="a127d5bce5f31e226483471f5e6f52a6b" name="a127d5bce5f31e226483471f5e6f52a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127d5bce5f31e226483471f5e6f52a6b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">Vector</a> &amp; <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy assignment. </p>
<p >This operator is defaulted so that this type is <a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">trivial</a>. </p>

</div>
</div>
<a id="ac61042ce2445816f46f909702348ba85" name="ac61042ce2445816f46f909702348ba85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac61042ce2445816f46f909702348ba85">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T &amp; <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the \( i \)-th coordinate. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;int, 5&gt;</a> <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>;</div>
<div class="line"><a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[0] = <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[1] = <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[2] = <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[3] = <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[4] = 0;</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the coordinate number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \( i \)-th coordinate of the vector </dd></dl>

</div>
</div>
<a id="a1e31709b45c087d0b00a188bf108697a" name="a1e31709b45c087d0b00a188bf108697a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e31709b45c087d0b00a188bf108697a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the \( i \)-th coordinate. </p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="structgf_1_1_vector.html">gf::Vector&lt;int, 5&gt;</a> <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a> = { 1, 3, 5, 7, 9 };</div>
<div class="line">std::printf(<span class="stringliteral">&quot;%i&quot;</span>, <a class="code hl_function" href="structgf_1_1_vector.html#a48195a02b7fe37c8c35e1ce89f4d6969">vec</a>[1]); <span class="comment">// prints 3</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>the coordinate number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The \( i \)-th coordinate of the vector </dd></dl>

</div>
</div>
<a id="a90e89cccc4b20d492c7a0dbe0b5d384b" name="a90e89cccc4b20d492c7a0dbe0b5d384b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e89cccc4b20d492c7a0dbe0b5d384b">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zero out the vector. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a68a904f7008f374c70a3da29cdbfa35a" name="a68a904f7008f374c70a3da29cdbfa35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a904f7008f374c70a3da29cdbfa35a">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise absolute value. </p>

</div>
</div>
<a id="a18e6f216b07d4883920dc5677a4fe92c" name="a18e6f216b07d4883920dc5677a4fe92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e6f216b07d4883920dc5677a4fe92c">&#9670;&nbsp;</a></span>angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Angle of a vector relative to the x-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The angle of the vector </dd></dl>

</div>
</div>
<a id="a8b7e8d54b4bfa8292c7927c5fc9f2386" name="a8b7e8d54b4bfa8292c7927c5fc9f2386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7e8d54b4bfa8292c7927c5fc9f2386">&#9670;&nbsp;</a></span>chebyshevDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T chebyshevDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chebyshev distance between two vectors. </p>
<p >The Chebyshev distance between two vectors is the Chebyshev length of the difference of the two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Chebyshev distance between the two vectors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#aafea65ac04f9577ddf229f2b67250db6" title="Chebyshev length of a vector.">chebyshevLength()</a> </dd></dl>

</div>
</div>
<a id="aafea65ac04f9577ddf229f2b67250db6" name="aafea65ac04f9577ddf229f2b67250db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafea65ac04f9577ddf229f2b67250db6">&#9670;&nbsp;</a></span>chebyshevLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T chebyshevLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Chebyshev length of a vector. </p>
<p >The Chebyshev length \( \|\mathbf{u}\|_{\infty} \) of a vector \( \mathbf{u} = (u_1, \ldots, u_N) \) is:</p>
<p class="formulaDsp">
\[ \|u\|_{\infty} = \max_{i = 1}^{N} |u_i| \]
</p>
<p >The Chebyshev length is also called the infinity norm or maximum norm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Chebyshev length of the vector</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a8b7e8d54b4bfa8292c7927c5fc9f2386" title="Chebyshev distance between two vectors.">chebyshevDistance()</a> </dd></dl>

</div>
</div>
<a id="a3e7af705704cd45f3120a8d0fb8233ac" name="a3e7af705704cd45f3120a8d0fb8233ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7af705704cd45f3120a8d0fb8233ac">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise clamp function. </p>
<p >Relative to two values. </p>

</div>
</div>
<a id="aafda04c94501a220cde97774e2bd6803" name="aafda04c94501a220cde97774e2bd6803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafda04c94501a220cde97774e2bd6803">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; clamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>hi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise clamp function. </p>
<p >Relative to two other vectors. </p>

</div>
</div>
<a id="ac9c7b0f2832ebb10c93344ada3e196c2" name="ac9c7b0f2832ebb10c93344ada3e196c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c7b0f2832ebb10c93344ada3e196c2">&#9670;&nbsp;</a></span>cross() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product for 2D vectors. </p>
<p >The cross product of 2D vectors is not really a cross product, it is the magnitude of the vector resulting from a 3D cross product of 2D vectors with \( z = 0 \). The cross product \( \mathbf{a} \times \mathbf{b} \) of the vectors \( \mathbf{a} \) and \( \mathbf{b} \) is:</p>
<p class="formulaDsp">
\[ \mathbf{a} \times \mathbf{b} = \mathbf{a}^{\perp} \cdot \mathbf{b} \]
</p>
<p >The 2D cross product is also known as the perp dot product or wedge product.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors </dd></dl>

</div>
</div>
<a id="ace7dc23b70392429718b79fe1d8b5e36" name="ace7dc23b70392429718b79fe1d8b5e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7dc23b70392429718b79fe1d8b5e36">&#9670;&nbsp;</a></span>cross() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt; cross </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 3 &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cross product for 3D vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cross product of the two vectors </dd></dl>

</div>
</div>
<a id="ac6fc841041b29612070bd3243e269d32" name="ac6fc841041b29612070bd3243e269d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fc841041b29612070bd3243e269d32">&#9670;&nbsp;</a></span>dirx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; dirx </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a vector in the x direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector in the x direction </dd></dl>

</div>
</div>
<a id="a634b932d718e72231b66831952a9175a" name="a634b932d718e72231b66831952a9175a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634b932d718e72231b66831952a9175a">&#9670;&nbsp;</a></span>diry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; diry </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a vector in the y direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The length of the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector in the y direction </dd></dl>

</div>
</div>
<a id="a68d59e5753b5619ff30f9f10659e5262" name="a68d59e5753b5619ff30f9f10659e5262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d59e5753b5619ff30f9f10659e5262">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scalar product. </p>
<p >The <a href="https://en.wikipedia.org/wiki/Dot_product">scalar product</a> or dot product of two vectors \( \mathbf{a} = (a_1, \ldots, a_N) \) and \( \mathbf{b} = (b_1, \ldots, b_N) \) is:</p>
<p class="formulaDsp">
\[ \mathbf{a} \cdot \mathbf{b} = \sum_{i=1}^{N} a_i b_i = a_1 b_1 + \ldots + a_N b_N \]
</p>
 
</div>
</div>
<a id="a603e565c3169edbd39c9c8cb2171b836" name="a603e565c3169edbd39c9c8cb2171b836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603e565c3169edbd39c9c8cb2171b836">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise equality operator. </p>

</div>
</div>
<a id="a1bbcb2190ca4bd2fb435f1e74f00c7db" name="a1bbcb2190ca4bd2fb435f1e74f00c7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbcb2190ca4bd2fb435f1e74f00c7db">&#9670;&nbsp;</a></span>euclideanDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T euclideanDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean distance between two vectors. </p>
<p >The Euclidean distance between two vectors is the Euclidean length of the difference of the two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean distance between the two vectors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a5b81f7458166ea6cf9a7365b947cf6a0" title="Euclidean length of a vector.">euclideanLength()</a> </dd></dl>

</div>
</div>
<a id="a5b81f7458166ea6cf9a7365b947cf6a0" name="a5b81f7458166ea6cf9a7365b947cf6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b81f7458166ea6cf9a7365b947cf6a0">&#9670;&nbsp;</a></span>euclideanLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T euclideanLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean length of a vector. </p>
<p >The Euclidean length \( \|\mathbf{u}\|_2 \) of a vector \( \mathbf{u} = (u_1, \ldots, u_N) \) is:</p>
<p class="formulaDsp">
\[ \|\mathbf{u}\|_2 = \sqrt{\sum_{i = 1}^{N} u_i^2} \]
</p>
<p >The Euclidean length is also called the 2-norm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Euclidean length of the vector</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a1bbcb2190ca4bd2fb435f1e74f00c7db" title="Euclidean distance between two vectors.">euclideanDistance()</a> </dd></dl>

</div>
</div>
<a id="ac8ddc8921435df311fc45b2a34e82a4f" name="ac8ddc8921435df311fc45b2a34e82a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ddc8921435df311fc45b2a34e82a4f">&#9670;&nbsp;</a></span>greaterThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; greaterThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise comparison operator. </p>

</div>
</div>
<a id="adeca9070f7b752a57d736a5643244eae" name="adeca9070f7b752a57d736a5643244eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca9070f7b752a57d736a5643244eae">&#9670;&nbsp;</a></span>inverseVectorTripleProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; inverseVectorTripleProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverse vector triple product. </p>
<p >The inverse <a href="https://en.wikipedia.org/wiki/Triple_product#Vector_triple_product">vector triple product</a> of vectors \( \mathbf{a} \), \( \mathbf{b} \) and \( \mathbf{c} \) is:</p>
<p class="formulaDsp">
\[ (\mathbf{a} \times \mathbf{b}) \times \mathbf{c} = -\mathbf{c} \times (\mathbf{a} \times \mathbf{b}) = -(\mathbf{c} \cdot \mathbf{b}) \mathbf{a} + (\mathbf{c} \cdot \mathbf{a}) \mathbf{b} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a94acbf0840ef48fe234997a3bd948083" title="Regular vector triple product.">vectorTripleProduct()</a> </dd></dl>

</div>
</div>
<a id="aabd4d75836a670db74ead8aa141bf088" name="aabd4d75836a670db74ead8aa141bf088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd4d75836a670db74ead8aa141bf088">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise lerp function. </p>

</div>
</div>
<a id="a8d10bb9a17347e5c51c10ad81319f0ba" name="a8d10bb9a17347e5c51c10ad81319f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d10bb9a17347e5c51c10ad81319f0ba">&#9670;&nbsp;</a></span>lessThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; lessThan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise comparison operator. </p>

</div>
</div>
<a id="ab7ac075b031168cc0333c60bf5f9ed91" name="ab7ac075b031168cc0333c60bf5f9ed91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ac075b031168cc0333c60bf5f9ed91">&#9670;&nbsp;</a></span>manhattanDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T manhattanDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manhattan distance between two vectors. </p>
<p >The Manhattan distance between two vectors is the Manhattan length of the difference of the two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Manhattan distance between the two vectors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a13e84f24664d006f2fff11c89059ef52" title="Manhattan length of a vector.">manhattanLength()</a> </dd></dl>

</div>
</div>
<a id="a13e84f24664d006f2fff11c89059ef52" name="a13e84f24664d006f2fff11c89059ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e84f24664d006f2fff11c89059ef52">&#9670;&nbsp;</a></span>manhattanLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T manhattanLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Manhattan length of a vector. </p>
<p >The Manhattan length \( \|\mathbf{u}\|_1 \) of a vector \( \mathbf{u} = (u_1, \ldots, u_N) \) is:</p>
<p class="formulaDsp">
\[ \|\mathbf{u}\|_1 = \sum_{i = 1}^{N} |u_i| \]
</p>
<p >The Manhattan length is also called the 1-norm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Manhattan length of the vector</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#ab7ac075b031168cc0333c60bf5f9ed91" title="Manhattan distance between two vectors.">manhattanDistance()</a> </dd></dl>

</div>
</div>
<a id="a0c86499fb47f364a434a53218d769afb" name="a0c86499fb47f364a434a53218d769afb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c86499fb47f364a434a53218d769afb">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise maximum. </p>

</div>
</div>
<a id="a3a442989e5524f0cb5eade69385467f6" name="a3a442989e5524f0cb5eade69385467f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a442989e5524f0cb5eade69385467f6">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise minimum. </p>

</div>
</div>
<a id="aa156019ca0df0875f1905e24dc008d05" name="aa156019ca0df0875f1905e24dc008d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa156019ca0df0875f1905e24dc008d05">&#9670;&nbsp;</a></span>naturalDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T naturalDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Natural distance between two vectors. </p>
<p >The natural distance between two vectors is the natural length of the difference of the two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural distance between the two vectors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a9e5d34e6962eb33c8d23a67c2a67a691" title="Natural length of a vector.">naturalLength()</a> </dd></dl>

</div>
</div>
<a id="a9e5d34e6962eb33c8d23a67c2a67a691" name="a9e5d34e6962eb33c8d23a67c2a67a691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5d34e6962eb33c8d23a67c2a67a691">&#9670;&nbsp;</a></span>naturalLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T naturalLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Natural length of a vector. </p>
<p >The natural length \( L \) of a vector: \( \mathbf{u} = (u_1, \ldots, u_N) \) is:</p>
<p class="formulaDsp">
\[ L = \|\mathbf{u}\|_1 + \|\mathbf{u}\|_2^2 = \sum_{i = 1}^{N} |u_i| + \sum_{i = 1}^{N} u_i^2 \]
</p>
<p >It's the sum of the Manhattan length and the square length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The natural length of the vector</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#aa156019ca0df0875f1905e24dc008d05" title="Natural distance between two vectors.">naturalDistance()</a> </dd></dl>

</div>
</div>
<a id="a4ff13e50288e1deeb196aa12df06d883" name="a4ff13e50288e1deeb196aa12df06d883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff13e50288e1deeb196aa12df06d883">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Normalize a vector. </p>
<p >The normalized vector of \( \mathbf{u} \) is a vector in the same direction but with a (euclidean) length of 1:</p>
<p class="formulaDsp">
\[ \frac{\mathbf{u}}{\|\mathbf{u}\|_2} \]
</p>
<p >A normalized vector is also called a <a href="https://en.wikipedia.org/wiki/Unit_vector">unit vector</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A normalized vector </dd></dl>

</div>
</div>
<a id="a254133a19c30421247b4ea76380b5024" name="a254133a19c30421247b4ea76380b5024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254133a19c30421247b4ea76380b5024">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality operator between two vectors. </p>

</div>
</div>
<a id="ac55421f25f24c00853208f886647d1b3" name="ac55421f25f24c00853208f886647d1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55421f25f24c00853208f886647d1b3">&#9670;&nbsp;</a></span>operator&amp;&amp;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; operator&amp;&amp; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise logical and operator. </p>

</div>
</div>
<a id="a3eb70d050088bf594043ed0ba06232ad" name="a3eb70d050088bf594043ed0ba06232ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb70d050088bf594043ed0ba06232ad">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left scalar multiplication. </p>

</div>
</div>
<a id="a1eaa37f51377425f1f3541e45922db98" name="a1eaa37f51377425f1f3541e45922db98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaa37f51377425f1f3541e45922db98">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar multiplication. </p>

</div>
</div>
<a id="a3f99ab5fa27fb2efd4a6398df8e260f6" name="a3f99ab5fa27fb2efd4a6398df8e260f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f99ab5fa27fb2efd4a6398df8e260f6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise multiplication. </p>

</div>
</div>
<a id="a705c85f28b50458abbb4544525722686" name="a705c85f28b50458abbb4544525722686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705c85f28b50458abbb4544525722686">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar multiplication and assignment. </p>

</div>
</div>
<a id="a4892f301f8dc21e642788115a738739c" name="a4892f301f8dc21e642788115a738739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892f301f8dc21e642788115a738739c">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise multiplication and assignment. </p>

</div>
</div>
<a id="ae8e76e287735d8ca7161a97c9ea3bbbf" name="ae8e76e287735d8ca7161a97c9ea3bbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e76e287735d8ca7161a97c9ea3bbbf">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left scalar addition. </p>

</div>
</div>
<a id="aef968d881f04036ccd6479be65f0866a" name="aef968d881f04036ccd6479be65f0866a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef968d881f04036ccd6479be65f0866a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar addition. </p>

</div>
</div>
<a id="a0839981cf3722b98600133bf7ab0b07e" name="a0839981cf3722b98600133bf7ab0b07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0839981cf3722b98600133bf7ab0b07e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise addition. </p>

</div>
</div>
<a id="a12778640823315695fecb02d5c79fb17" name="a12778640823315695fecb02d5c79fb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12778640823315695fecb02d5c79fb17">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar addition and assignment. </p>

</div>
</div>
<a id="a765312e5842339960abb7d536bfbe1b2" name="a765312e5842339960abb7d536bfbe1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765312e5842339960abb7d536bfbe1b2">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise addition and assignment. </p>

</div>
</div>
<a id="a6a7de3c412b03b7efdb9230ca97d4118" name="a6a7de3c412b03b7efdb9230ca97d4118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7de3c412b03b7efdb9230ca97d4118">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left scalar substraction. </p>

</div>
</div>
<a id="ac828d7a7cdbdda752c8ae435ea12df33" name="ac828d7a7cdbdda752c8ae435ea12df33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac828d7a7cdbdda752c8ae435ea12df33">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar substraction. </p>

</div>
</div>
<a id="a5216834ff74a5658248595cf54eaca02" name="a5216834ff74a5658248595cf54eaca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5216834ff74a5658248595cf54eaca02">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise substraction. </p>

</div>
</div>
<a id="a3bc28e77627701136f80d1977cfff1da" name="a3bc28e77627701136f80d1977cfff1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc28e77627701136f80d1977cfff1da">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise unary minus. </p>

</div>
</div>
<a id="a5106adae988b1e08b36c92f9ec6bef15" name="a5106adae988b1e08b36c92f9ec6bef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106adae988b1e08b36c92f9ec6bef15">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar substraction and assignment. </p>

</div>
</div>
<a id="a2b182de38d705ad74702e4ac27a43148" name="a2b182de38d705ad74702e4ac27a43148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b182de38d705ad74702e4ac27a43148">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator-= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise substraction and assignment. </p>

</div>
</div>
<a id="a4303bee223d720052cdeb47ef5737255" name="a4303bee223d720052cdeb47ef5737255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4303bee223d720052cdeb47ef5737255">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Left scalar division. </p>

</div>
</div>
<a id="a39bb370ac82deba952f69392149c2915" name="a39bb370ac82deba952f69392149c2915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bb370ac82deba952f69392149c2915">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N, typename E  = typename std::enable_if&lt;std::is_arithmetic&lt;U&gt;::value, U&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar division. </p>

</div>
</div>
<a id="ab881f7d5127c35d12326813626b3ede0" name="ab881f7d5127c35d12326813626b3ede0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab881f7d5127c35d12326813626b3ede0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; std::common_type_t&lt; T, U &gt;, N &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise division. </p>

</div>
</div>
<a id="abb635d386ec828efac5c2acbca5e7362" name="abb635d386ec828efac5c2acbca5e7362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb635d386ec828efac5c2acbca5e7362">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Right scalar division and assignment. </p>

</div>
</div>
<a id="ada0fe611e4f39fda1147dcb21f9a3df9" name="ada0fe611e4f39fda1147dcb21f9a3df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0fe611e4f39fda1147dcb21f9a3df9">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp; operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; U, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise division and assignment. </p>

</div>
</div>
<a id="a2623a6fdbc97d51457510e165fa8088b" name="a2623a6fdbc97d51457510e165fa8088b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2623a6fdbc97d51457510e165fa8088b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator between two vectors. </p>

</div>
</div>
<a id="a0809b1e380f831557e4c6eef6111b30f" name="a0809b1e380f831557e4c6eef6111b30f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0809b1e380f831557e4c6eef6111b30f">&#9670;&nbsp;</a></span>operator|()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Archive &amp; operator| </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialize and deserialize a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ar</td><td>The archive </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to serialize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>gf::Serialize, gf::Deserialiser </dd></dl>

</div>
</div>
<a id="a8cf0c3d205c768d088a006a1fd7097f0" name="a8cf0c3d205c768d088a006a1fd7097f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf0c3d205c768d088a006a1fd7097f0">&#9670;&nbsp;</a></span>operator||()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt; operator|| </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise logical or operator. </p>

</div>
</div>
<a id="a1aceef07438afe7fb1157efe584591cc" name="a1aceef07438afe7fb1157efe584591cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aceef07438afe7fb1157efe584591cc">&#9670;&nbsp;</a></span>perp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; perp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perpendicular vector. </p>
<p >The perpendicular vector \( \mathbf{u}^{\perp} \) of vector \( \mathbf{u} = (x, y) \) is:</p>
<p class="formulaDsp">
\[ \mathbf{u}^{\perp} = (-y, x) \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A perpendicular vector </dd></dl>

</div>
</div>
<a id="a056b79951b622a9fa2b28d172e3012db" name="a056b79951b622a9fa2b28d172e3012db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056b79951b622a9fa2b28d172e3012db">&#9670;&nbsp;</a></span>projx()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; projx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project the vector on the x axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection of the vector on the x axis </dd></dl>

</div>
</div>
<a id="a51f4ccecff2cf95ae1313eb9bcc99d66" name="a51f4ccecff2cf95ae1313eb9bcc99d66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f4ccecff2cf95ae1313eb9bcc99d66">&#9670;&nbsp;</a></span>projy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; projy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Project the vector on the y axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The projection of the vector on the y axis </dd></dl>

</div>
</div>
<a id="a1ffb16899f596dfde6ed7945ca363697" name="a1ffb16899f596dfde6ed7945ca363697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffb16899f596dfde6ed7945ca363697">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; bool, N &gt;&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise selection operator. </p>

</div>
</div>
<a id="ab2c56c0264d3d4f355ac8ac1f7849491" name="ab2c56c0264d3d4f355ac8ac1f7849491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c56c0264d3d4f355ac8ac1f7849491">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; int, N &gt; sign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Component-wise sign value. </p>

</div>
</div>
<a id="a6c2b906d7231d200eb766187b5f51936" name="a6c2b906d7231d200eb766187b5f51936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2b906d7231d200eb766187b5f51936">&#9670;&nbsp;</a></span>squareDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T squareDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square Euclidean distance between two vectors. </p>
<p >The square Euclidean distance between two vectors is the square Euclidean length of the difference of the two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>A first vector </td></tr>
    <tr><td class="paramname">rhs</td><td>A second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square Euclidean distance between the two vectors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a1955a31725e521021b0be0ab2871be50" title="Square Euclidean length of a vector.">squareLength()</a>, <a class="el" href="structgf_1_1_vector.html#a1bbcb2190ca4bd2fb435f1e74f00c7db" title="Euclidean distance between two vectors.">euclideanDistance()</a> </dd></dl>

</div>
</div>
<a id="a1955a31725e521021b0be0ab2871be50" name="a1955a31725e521021b0be0ab2871be50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1955a31725e521021b0be0ab2871be50">&#9670;&nbsp;</a></span>squareLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T squareLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square Euclidean length of a vector. </p>
<p >The square Euclidean length \( \|\mathbf{u}\|_2^2 \) of a vector \( \mathbf{u} = (u_1, \ldots, u_N) \) is:</p>
<p class="formulaDsp">
\[ \|\mathbf{u}\|_2^2 = \sum_{i = 1}^{N} u_i^2 \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>A vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The square Euclidean length of the vector</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#a5b81f7458166ea6cf9a7365b947cf6a0" title="Euclidean length of a vector.">euclideanLength()</a>, <a class="el" href="structgf_1_1_vector.html#a6c2b906d7231d200eb766187b5f51936" title="Square Euclidean distance between two vectors.">squareDistance()</a> </dd></dl>

</div>
</div>
<a id="a15f9e895116590549ded3adf7303fc80" name="a15f9e895116590549ded3adf7303fc80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f9e895116590549ded3adf7303fc80">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two vectors. </p>

</div>
</div>
<a id="a1ba83d14d9bc5292fcf5ab39f596440b" name="a1ba83d14d9bc5292fcf5ab39f596440b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba83d14d9bc5292fcf5ab39f596440b">&#9670;&nbsp;</a></span>unit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; unit </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unit vector in a specified direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle of the direction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unit vector </dd></dl>

</div>
</div>
<a id="a48195a02b7fe37c8c35e1ce89f4d6969" name="a48195a02b7fe37c8c35e1ce89f4d6969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48195a02b7fe37c8c35e1ce89f4d6969">&#9670;&nbsp;</a></span>vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto vec </td>
          <td>(</td>
          <td class="paramtype">Types...&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> -&gt; <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt;std::common_type_t&lt;Types...&gt;, sizeof...(Types)&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Universal vector factory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>The values for the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with a deduced type and initialized with the values provided </dd></dl>

</div>
</div>
<a id="a94acbf0840ef48fe234997a3bd948083" name="a94acbf0840ef48fe234997a3bd948083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94acbf0840ef48fe234997a3bd948083">&#9670;&nbsp;</a></span>vectorTripleProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt; vectorTripleProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgf_1_1_vector.html">Vector</a>&lt; T, 2 &gt;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Regular vector triple product. </p>
<p >The regular <a href="https://en.wikipedia.org/wiki/Triple_product#Vector_triple_product">vector triple product</a> of vectors \( \mathbf{a} \), \( \mathbf{b} \) and \( \mathbf{c} \) is:</p>
<p class="formulaDsp">
\[ \mathbf{a} \times (\mathbf{b} \times \mathbf{c}) = (\mathbf{a} \cdot \mathbf{c}) \mathbf{b} - (\mathbf{a} \cdot \mathbf{b}) \mathbf{c} \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structgf_1_1_vector.html#adeca9070f7b752a57d736a5643244eae" title="Inverse vector triple product.">inverseVectorTripleProduct()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a247825a4b27adde52e67107d87987ca8" name="a247825a4b27adde52e67107d87987ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247825a4b27adde52e67107d87987ca8">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="structgf_1_1_vector.html">gf::Vector</a>&lt; T, N &gt;::data[N]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The internal representation of the vector. </p>
<p >A vector is represented with an array of <code>N</code> values of type <code>T</code>. It can be accessed directly, like an array or like a pointer, which can ease interoperability with other libraries. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
